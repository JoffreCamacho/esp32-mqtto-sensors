//For ATRIUM CDR with love by Joffre Camacho - 2023
//#include <gpio_viewer.h>
#include <WiFi.h>
#include <ESPmDNS.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>
#include <PubSubClient.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoJson.h>
#include <NewPing.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>
#include "config.h"
#include "WiFiManager.h" 
#include <driver/adc.h>
#include <esp_adc_cal.h>
#include <SoftwareSerial.h>
//#include <Wire.h> 

Adafruit_BME280 bme;  // I2C interface for BME280
OneWire oneWire1(ONE_WIRE_BUS1);
OneWire oneWire2(ONE_WIRE_BUS2);
DallasTemperature sensors1(&oneWire1);
DallasTemperature sensors2(&oneWire2);

SoftwareSerial co2Serial(CO2_RX_PIN, CO2_TX_PIN);
WiFiClient wClient;
PubSubClient mqttClient(wClient);

bool relayState = false;     // Variable to store the state of the relay
bool relay2State = false;    // Variable to store the state of the second relay
bool relay3State = false;    // Variable to store the state of the third relay
bool mqttConnected = false;  // Variable to track MQTT connection status
bool isBME280Initialized = false;


uint32_t lastResetTime = 0; // Stores the last reset time in milliseconds
uint32_t lastAttemptTime = 0; // Outside of any function
         
const unsigned long attemptInterval = 5000;  // 5 seconds
const unsigned long resetInterval = 600000; // 10 minutes = 600000 milliseconds

NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE);  // NewPing setup

void initializePins() { // List of all GPIO pins you intend to initialize
  int gpioPins[] = {5, 12, 13, 14, 15, 16, 17, 18, 19, 25, 26, 27, 32, 33}; 
  int numPins = sizeof(gpioPins) / sizeof(gpioPins[0]); 
  
  for(int i = 0; i < numPins; i++) {
    pinMode(gpioPins[i], OUTPUT);
    digitalWrite(gpioPins[i], LOW); 
  }
  digitalWrite(RELAY_PIN, HIGH); // Ensure relay starts off
  digitalWrite(RELAY2_PIN, HIGH); // Ensure relay starts off
  digitalWrite(RELAY3_PIN, HIGH); // Ensure relay starts off
  pinMode(CO2_SENSOR_PIN, INPUT);
  pinMode(PH_SENSOR_PIN, INPUT);
  pinMode(TURBIDITY_SENSOR_PIN, INPUT);
  pinMode(TDS_SENSOR_PIN, INPUT);
  pinMode(LIGHT_SENSOR_PIN, INPUT);
}
void setupWiFi() {
  Serial.println("Connecting to WiFi...");
  WiFiManager::connect(ssid, password); 
}
void setupOTA() {
  ArduinoOTA
    .onStart([]() {
      String type;
      if (ArduinoOTA.getCommand() == U_FLASH)
        type = "sketch";
      else
        type = "filesystem";
      Serial.println("Start updating: " + type);
    })
    .onEnd([]() {
      Serial.println("\nEnd");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      Serial.printf("Error[%u]: ", error);
      if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
      else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
      else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
      else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
      else if (error == OTA_END_ERROR) Serial.println("End Failed");
    });

  ArduinoOTA.begin();
}
void setupMQTT() {
  mqttClient.setServer(mqttServer, mqttPort);
  mqttClient.setCallback(mqttCallback);
}
void initializeI2C() {
  Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN); // Initialize I2C with specified pins
  isBME280Initialized = bme.begin(0x76, &Wire); // Try to initialize the sensor

  if (!isBME280Initialized) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
  } else {
    Serial.println("BME280 sensor initialized successfully!");
  }
}
void setupSensors() {
  co2Serial.begin(9600); 
  sensors1.begin();
  sensors2.begin();
}
void setup() {
  Serial.begin(115200);
  initializePins();  
  Serial.println("Pins asignados");
  setupWiFi();
  setupOTA();
  setupMQTT();
  setupSensors();
  initializeI2C();

  Serial.println("Ready");
  analogReadResolution(12);

}
int readCO2() {
  byte response[9];  // Buffer to store response from the sensor
  co2Serial.write((byte)0xFF);  // Send command to read CO2
  co2Serial.write((byte)0x01);
  co2Serial.write((byte)0x86);
  co2Serial.write((byte)0x00);
  co2Serial.write((byte)0x00);
  co2Serial.write((byte)0x00);
  co2Serial.write((byte)0x00);
  co2Serial.write((byte)0x00);
  co2Serial.write((byte)0x79);
  
  for (int i = 0; i < 9; i++) {
    response[i] = co2Serial.read();
  }
  
  int ppm = (256 * (int)response[2]) + (int)response[3];
  return ppm;
}
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  Serial.println("Entered mqttCallback");
  String message = "";
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }

  Serial.println("Message: " + message);

  // Depending on the topic, control the corresponding relay
  if (String(topic) == "esp32/relay1") {
    if (message == "on") {
      digitalWrite(RELAY_PIN, LOW);
      relayState = true;
      Serial.println("Relay 1 turned on");
    } else if (message == "off") {
      digitalWrite(RELAY_PIN, HIGH);
      relayState = false;
      Serial.println("Relay 1 turned off");
    }
  } else if (String(topic) == "esp32/relay2") {
    if (message == "on") {
      digitalWrite(RELAY2_PIN, LOW);
      relay2State = true;
      Serial.println("Relay 2 turned on");
    } else if (message == "off") {
      digitalWrite(RELAY2_PIN, HIGH);
      relay2State = false;
      Serial.println("Relay 2 turned off");
    }
  } else if (String(topic) == "esp32/relay3") {
    if (message == "on") {
      digitalWrite(RELAY3_PIN, LOW);
      relay3State = true;
      Serial.println("Relay 3 turned on");
    } else if (message == "off") {
      digitalWrite(RELAY3_PIN, HIGH);
      relay3State = false;
      Serial.println("Relay 3 turned off");
    }
  }
}
void connectToMqtt() {
  if (!mqttClient.connected()) {
    unsigned long currentMillis = millis();
    if (currentMillis - lastAttemptTime >= attemptInterval) {
      Serial.println("Connecting to MQTT server...");
      if (mqttClient.connect("ESP32Client")) {
        Serial.println("Connected to MQTT server");
        mqttClient.subscribe("esp32/relay1");
        mqttClient.subscribe("esp32/relay2");
        mqttClient.subscribe("esp32/relay3");
        mqttConnected = true; // Update connection status
      } else {
        Serial.print("Failed to connect to MQTT server, rc=");
        Serial.println(mqttClient.state());
        lastAttemptTime = currentMillis; // Update the last attempt time
      }
    }
  }
}
void readAndPublishSensorData() {
  sensors1.requestTemperatures();
  float temperatureC1 = sensors1.getTempCByIndex(0);  
  sensors2.requestTemperatures();
  float temperatureC2 = sensors2.getTempCByIndex(0);  

  // Initialize variables for BME280 data
  float bmeTemperature = -99.0;  // Default value if sensor is not detected
  float pressure = -99.0;        // Default value if sensor is not detected
  float humidity = -99.0;        // Default value if sensor is not detected

  bmeTemperature = bme.readTemperature();
  pressure = bme.readPressure();
  humidity = bme.readHumidity();

  const int numSamples = 10; 
  int lightIntensity = 0;
  int turbidity = 0;
  int tdsValue = 0;
  int CO2 = readCO2();
  int phValue = 0;

  for (int i = 0; i < numSamples; i++) {
    lightIntensity += analogRead(LIGHT_SENSOR_PIN);
  }
  lightIntensity /= numSamples;

  unsigned int uS = sonar.ping();
  float distance = uS / US_ROUNDTRIP_CM;  

  String macAddress = WiFi.macAddress();
  StaticJsonDocument<220> doc;
  doc["macAddress"] = macAddress;
  doc["temperatureC1"] = temperatureC1;  
  doc["temperatureC2"] = temperatureC2;  
  doc["bmeTemperature"] = bmeTemperature;
  doc["pressure"] = pressure;
  doc["humidity"] = humidity;
  doc["lightIntensity"] = lightIntensity;
  doc["turbidity"] = turbidity;
  doc["tds"] = tdsValue;
  doc["CO2"] = CO2;
  doc["phValue"] = phValue;  
  doc["distance"] = distance;
  char jsonBuffer[512];
  serializeJson(doc, jsonBuffer);  
  if (mqttConnected) {
    mqttClient.publish("esp32/sensorData", jsonBuffer);
  }
}
void loop() {

  unsigned long currentMillis = millis();

  // Check if it's time to reset
  if (currentMillis - lastResetTime >= resetInterval) {
    Serial.println("5 minutes passed, resetting...");
    ESP.restart(); // Resets the ESP32
    lastResetTime = currentMillis; // Update the last reset time, though not strictly necessary as the device will restart
  }

  // Check if it's time to recheck the BME280 sensor
  static unsigned long lastSensorCheckTime = 0;
  if (currentMillis - lastSensorCheckTime >= 60000) { // Check every 60 seconds
    initializeI2C();
    lastSensorCheckTime = currentMillis;
  }

  if (!mqttConnected) {
    connectToMqtt();
  }
  mqttClient.loop();
  ArduinoOTA.handle();

  readAndPublishSensorData();

  delay(2000);  // Delay for 2 seconds (must not be higher that 5 or OTA will not work)
}
