//For ATRIUM CDR with love by Joffre Camacho - 2023
//#include <gpio_viewer.h>
#include <WiFi.h>
#include <ESPmDNS.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>
#include <PubSubClient.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoJson.h>
#include <NewPing.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>
#include "config.h"
#include "WiFiManager.h" // Include the WiFiManager
#include <driver/adc.h>
#include <esp_adc_cal.h>

// 21 SCL 22 SDA [DER]
// GPIO [23*,22*,1,3,21*,19,18*,5,17,16,4,0,2,15,8,7,6][DER]
// GPIO [36*,39*,34*,35*,32*,33-,25-,26*,27-,14*,12,13,9,10,11][IZQ]
// AVAILABLE [1,3,19,5,17,16,4,0,2,15,8,7,6,12,13,9,10,11]

Adafruit_BME280 bme;  // I2C interface for BME280
//OneWire oneWire(ONE_WIRE_BUS);
OneWire oneWire1(ONE_WIRE_BUS1);
OneWire oneWire2(ONE_WIRE_BUS2);
DallasTemperature sensors1(&oneWire1);
DallasTemperature sensors2(&oneWire2);

WiFiClient wClient;
PubSubClient mqttClient(wClient);

bool relayState = false;     // Variable to store the state of the relay
bool relay2State = false;    // Variable to store the state of the second relay
bool relay3State = false;    // Variable to store the state of the third relay
bool mqttConnected = false;  // Variable to track MQTT connection status
float temperatureC1;
float temperatureC2;

unsigned long lastResetTime = 0; // Stores the last reset time in milliseconds
unsigned long lastAttemptTime = 0;           // Outside of any function
const unsigned long attemptInterval = 5000;  // 5 seconds
const unsigned long resetInterval = 300000; // 5 minutes = 300000 milliseconds

NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE);  // NewPing setup

void setup() {

    // List of all GPIO pins you intend to initialize
  int gpioPins[] = {0, 1, 2, 3, 4, 5, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23, 25, 26, 27, 32, 33}; // Only include valid output capable pins
  int numPins = sizeof(gpioPins) / sizeof(gpioPins[0]); // Number of pins in the array
  adc_chars = (esp_adc_cal_characteristics_t *)calloc(1, sizeof(esp_adc_cal_characteristics_t));
  esp_adc_cal_value_t val_type = esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, DEFAULT_VREF, adc_chars);
  for(int i = 0; i < numPins; i++) {
    pinMode(gpioPins[i], OUTPUT);
    digitalWrite(gpioPins[i], LOW); // Set each pin to LOW
  }

  WiFiManager::connect(ssid, password); // Use WiFiManager to connect

  ArduinoOTA
    .onStart([]() {
      String type;
      if (ArduinoOTA.getCommand() == U_FLASH)
        type = "sketch";
      else
        type = "filesystem";
      Serial.println("Start updating: ");
    })
    .onEnd([]() {
      Serial.println("\nEnd");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      Serial.printf("Error[%u]: ", error);
      if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
      else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
      else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
      else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
      else if (error == OTA_END_ERROR) Serial.println("End Failed");
    });

  ArduinoOTA.begin();

  Serial.println("Ready");
  Serial.print("IP address: ");
  //addLog(WiFi.localIP());
  IPAddress ip = WiFi.localIP();
  String ipString = ip.toString();

  mqttClient.setServer(mqttServer, mqttPort);
  mqttClient.setCallback(mqttCallback);

  // Serial.begin(115200);
  analogReadResolution(12);
  
   // Initialize ADC calibration characteristics
  adc_chars = (esp_adc_cal_characteristics_t *)calloc(1, sizeof(esp_adc_cal_characteristics_t));
  
  bme.begin(0x76);
  sensors1.begin();
  sensors2.begin();
  digitalWrite(RELAY_PIN, HIGH); // Ensure relay starts off
  digitalWrite(RELAY2_PIN, HIGH); // Ensure relay starts off
  digitalWrite(RELAY3_PIN, HIGH); // Ensure relay starts off
  // pinMode(LIGHT_SENSOR_PIN, INPUT);  //this can create idm
  pinMode(CO2_SENSOR_PIN, INPUT);
  pinMode(PH_SENSOR_PIN, INPUT);
  pinMode(TURBIDITY_SENSOR_PIN, INPUT);
  pinMode(TDS_SENSOR_PIN, INPUT);
  pinMode(LIGHT_SENSOR_PIN, INPUT);
}

uint32_t readADC_Calibrated(int gpioPin) {
    adc1_channel_t channel = getADCChannel(gpioPin);
    uint32_t adc_reading = 0;
    for (int i = 0; i < NO_OF_SAMPLES; i++) {
        adc_reading += adc1_get_raw(channel);
    }
    adc_reading /= NO_OF_SAMPLES;
    uint32_t voltage = esp_adc_cal_raw_to_voltage(adc_reading, adc_chars);
    return voltage;
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  Serial.println("Entered mqttCallback");
  String message = "";
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }

  Serial.println("Message: " + message);

  // Depending on the topic, control the corresponding relay
  if (String(topic) == "esp32/relay1") {
    if (message == "on") {
      digitalWrite(RELAY_PIN, LOW);
      relayState = true;
      Serial.println("Relay 1 turned on");
    } else if (message == "off") {
      digitalWrite(RELAY_PIN, HIGH);
      relayState = false;
      Serial.println("Relay 1 turned off");
    }
  } else if (String(topic) == "esp32/relay2") {
    if (message == "on") {
      digitalWrite(RELAY2_PIN, LOW);
      relay2State = true;
      Serial.println("Relay 2 turned on");
    } else if (message == "off") {
      digitalWrite(RELAY2_PIN, HIGH);
      relay2State = false;
      Serial.println("Relay 2 turned off");
    }
  } else if (String(topic) == "esp32/relay3") {
    if (message == "on") {
      digitalWrite(RELAY3_PIN, LOW);
      relay3State = true;
      Serial.println("Relay 3 turned on");
    } else if (message == "off") {
      digitalWrite(RELAY3_PIN, HIGH);
      relay3State = false;
      Serial.println("Relay 3 turned off");
    }
  }
}

void connectToMqtt() {
  if (!mqttClient.connected()) {
    unsigned long currentMillis = millis();
    if (currentMillis - lastAttemptTime >= attemptInterval) {
      Serial.println("Connecting to MQTT server...");
      if (mqttClient.connect("ESP32Client")) {
        Serial.println("Connected to MQTT server");
        mqttClient.subscribe("esp32/relay1");
        mqttClient.subscribe("esp32/relay2");
        mqttClient.subscribe("esp32/relay3");
        mqttConnected = true; // Update connection status
      } else {
        Serial.print("Failed to connect to MQTT server, rc=");
        Serial.println(mqttClient.state());
        lastAttemptTime = currentMillis; // Update the last attempt time
      }
    }
  }
}

adc1_channel_t getADCChannel(int gpioPin) {
    switch(gpioPin) {
        case 32: return ADC1_CHANNEL_4; 
        case 33: return ADC1_CHANNEL_5; 
        case 34: return ADC1_CHANNEL_6;
        case 35: return ADC1_CHANNEL_7;
        case 36: return ADC1_CHANNEL_0;
        case 39: return ADC1_CHANNEL_3;
        default: return ADC1_CHANNEL_0; // Default case if not found
    }
}

void loop() {

  unsigned long currentMillis = millis();

  // Check if it's time to reset
  if (currentMillis - lastResetTime >= resetInterval) {
    Serial.println("5 minutes passed, resetting...");
    ESP.restart(); // Resets the ESP32
    lastResetTime = currentMillis; // Update the last reset time, though not strictly necessary as the device will restart
  }

  if (!mqttConnected) {
    connectToMqtt();
  }
  mqttClient.loop();
  ArduinoOTA.handle();

  // Read temperature
  sensors1.requestTemperatures();
  temperatureC1 = sensors1.getTempCByIndex(0);  // Temperature from sensor on ONE_WIRE_BUS1 BOX
  // temperatureC1 = analogRead(ONE_WIRE_BUS1);

  sensors2.requestTemperatures();
  temperatureC2 = sensors2.getTempCByIndex(0);  // Temperature from sensor on ONE_WIRE_BUS2 WATER
  // temperatureC2 = analogRead(ONE_WIRE_BUS2);

  // Initialize variables for BME280 data
  float bmeTemperature = -99.0;  // Default value if sensor is not detected
  float pressure = -99.0;        // Default value if sensor is not detected
  float humidity = -99.0;        // Default value if sensor is not detected

  // Do not reinitialize; just read from the sensor
  bmeTemperature = bme.readTemperature();
  pressure = bme.readPressure();
  humidity = bme.readHumidity();

  // Multisampling for analog sensors
  const int numSamples = 10;  // Number of samples to take
  int lightIntensity = 0;
  int turbidity = 0;
  int tdsValue = 0;
  int CO2 = 0;
  int phValue = 0;

  // Take multiple samples and sum the readings
  for (int i = 0; i < numSamples; i++) {
  lightIntensity += analogRead(LIGHT_SENSOR_PIN);
  //turbidity += analogRead(TURBIDITY_SENSOR_PIN);
  //tdsValue += analogRead(TDS_SENSOR_PIN);
  //CO2 += analogRead(CO2_SENSOR_PIN);
  //phValue += analogRead(PH_SENSOR_PIN);
  }
  // Calculate the average by dividing the sum by the number of samples
  lightIntensity /= numSamples;
  // turbidity /= numSamples;
  // tdsValue /= numSamples;
  // CO2 /= numSamples;
  // phValue /= numSamples;
  //lightIntensity = readADC_Calibrated(LIGHT_SENSOR_PIN);
  //lightIntensity = analogRead(LIGHT_SENSOR_PIN);
  //turbidity = readADC_Calibrated(TURBIDITY_SENSOR_PIN);
  //tdsValue = readADC_Calibrated(TDS_SENSOR_PIN);
  //CO2 = readADC_Calibrated(CO2_SENSOR_PIN);
  //phValue = readADC_Calibrated(PH_SENSOR_PIN);

  unsigned int uS = sonar.ping();
  float distance = uS / US_ROUNDTRIP_CM;  // Convert ping time to distance in cm
  // Get ESP32 MAC address
  String macAddress = WiFi.macAddress();
  // Create JSON document
  StaticJsonDocument<220> doc;
  //DynamicJsonDocument doc(220);
  doc["macAddress"] = macAddress;
  doc["temperatureC1"] = temperatureC1;  // BOX
  doc["temperatureC2"] = temperatureC2;  // TANK temperature in Celsius
  doc["bmeTemperature"] = bmeTemperature;
  doc["pressure"] = pressure;
  doc["humidity"] = humidity;
  doc["lightIntensity"] = lightIntensity;
  doc["turbidity"] = turbidity;
  doc["tds"] = tdsValue;
  doc["CO2"] = CO2;
  doc["phValue"] = phValue;  // Include PH value in JSON
  doc["distance"] = distance;
  char jsonBuffer[512];
  serializeJson(doc, jsonBuffer);  // Serialize the JSON document
  if (mqttConnected) {
    mqttClient.publish("esp32/sensorData", jsonBuffer);
  }


  delay(2000);  // Delay for 2 seconds (must not be higher that 5 or OTA will not work)
}
